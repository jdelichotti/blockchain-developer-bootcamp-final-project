// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

/// @title SmartBet
/// @author J.Gabriel Delichotti
/**  @notice This contract allows the registration of soccer bets so that bettors can win the jackpot generated by the different bets.
    In addition, the contract has Sponsors that provide liquidity at the beginning of the bet to attract bettors. In return, they will charge a commission for each bet.
    Initially this commission is defined in the contract.*/
/** @dev The application allows the owner of the smart contract:
 - to register bets, 
 - Close the event to stop receiving money from bettors, 
 - Define the final result of the bet (in the future it would be necessary to develop an oracle).
 - Trigger the payment to Sponsors and Bettors (who won).*/

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SmartBet is Ownable,ReentrancyGuard{

    using SafeMath for uint;
    
    ///// EVENTS /////
    event Deposit(address indexed sender, uint amount, uint balance);
    event CreateBet (uint indexed betId, string LocalTeam, string VisitorTeam,address indexed owner);
    event AddBetSponsor(uint indexed betId, address indexed sponsor, uint amount);
    event AddBetGambler(uint indexed betId, address indexed gambler, uint amount);
    event OpenBet (address indexed owner, uint indexed betIndex);
    event CloseBet (address indexed owner, uint indexed betIndex);
    event CountingVotesBet (address indexed owner, uint indexed betIndex);
    event ResultsReadyBet (address indexed owner, uint indexed betIndex);
    event ReadyForPaymentBet (address indexed owner, uint indexed betIndex);
    event FinishedBet (address indexed owner, uint indexed betIndex);
    event GamblerPayment (address gamblerAddress, uint price);
    event SponsorPayment (address sponsorAddress, uint price);
    
    
    ///// ENUM /////
    enum BetStates {BetFunding, Created, Open, Closed, ResultsReady, ReadyForPayment, Finished}
    enum BetOptions {LocalWin, VistorWin, Drawn}
    enum BetResults {NotStarted, LocalWin, VistorWin, Drawn, Unknown}

    ///// GENERALE PARAMETERS
    /// @dev These data is fixex in the contract. 
    uint NUM_SPONSOR_REQUIRED = 2;
    uint MIN_SPONSOR_AMOUNT = 0.00000005 ether;
    uint MIN_BET_AMOUNT = 0.00000001 ether;

    ///// STORAGE VARIABLES /////
    /// @dev These values represent the fees that the Sponsors and the owner of the app will charge for each bet they place.
    uint SponsorFee = 5;
    uint ownerFee = 5;


    /** @dev The structure contains all the necessary data to register a new bet.
        It also adds up the amounts entered for each possible outcome as well as the amount contributed by the Sponsors.
        This structure is then entered into a mapping (betBook).*/
    struct BetDefinition {
        uint betId;
        string localTeam;
        string visitorTeam;
        BetStates state;   
        BetResults results;     
        uint sponsorsCount;
        uint gamblersCount;
        uint winnersCount;
        uint initialAmount;       // Amount inyected by the Sponsor
        uint localWiningAmount;   // Local Winning Price (aprox)
        uint visitorWiningAmount; // Visitor Winning Price (aprox)
        uint drawnAmount;         // Draw Winning Price (aprox)
    }    
    BetDefinition[] public betBook;

    /** @dev The structure defines the information necessary to include a Sponsor in a bet.
        - SponsorAccount: Represents the address where the fee will be paid.
        - SponsorAmount: It is the money that each Sponsor contribute at the beginning of the bet to attract gamblers.
        - SponsorFeeAmount: It is the money paid to each Sponsor at the end of the bet.
        For each bet (betId) an array of Sponsors is created and added to a mapping (betSponsors). The index of the mapping is the ID of the bet.
     */
    struct Sponsor {
        address payable sponsorAccount;
        uint sponsorAmount;
        uint sponsorFeeAmount;
        BetResults result;        
    }   
    mapping (uint => Sponsor[]) public betSponsors;


    /***  @dev The structure defines the information necessary to include a Gambler in a bet.
    - GamblerAccount: Represents the gambler's address. If the chosen result is finally given, it will be the address where he/she will collect the prize.
    - betOption: It is the result for which the gambler entered money. It is the result that he expects to happen.
    - betAmount: This is the amount of money placed on the bet.
    - betRewardPayment: It is the amount that the gambler ends up collecting at the end of the bet. Initially it starts at zero.
    For each bet (betId) an array of gambler is created and added to a mapping (betGamblers). The index of the mapping is the ID of the bet.*/
    
    struct Gambler {
        address payable gamblerAccount;
        BetOptions betOption;
        uint betAmount;
        uint betRewardPayment;
    }
    mapping (uint => Gambler[]) public betGamblers;


    receive() external payable {
        emit Deposit(msg.sender, msg.value, address(this).balance);
    }


    //////////// MODIFIERS ////////////////////////
    /// @dev This modifier is used in most functions to ensure that you are trying to trade a bet that actually exists.
    /// @param _betIndex It's the index of the bet
    modifier betExists(uint _betIndex) {
        require(_betIndex < betBook.length, "bet does not exist");
        _;
    }


    /// @author J.Gabriel Delichotti
    /// @notice Allows you to register new bets. This action can only be performed by the owner of the contract. 
    /**  @dev Create a bet by defining the teams participating in the match and initiating the internal variables of the BetDefinition structure.
        This structure is then aggregated into an array of bets (betBook).
        This action can only be done by the contract's owner (Using the openZeppelin library - Ownable*/
    /// @param _localTeam Defines home team
    /// @param _visitorTeam Defines the visiting team    
    /// @return betId is the ID created for the new bet
    function createBet(string memory _localTeam,string memory _visitorTeam) public onlyOwner returns (uint betId) {        
        uint betIndex = betBook.length;
        betBook.push(
            BetDefinition({
                betId:betIndex,
                localTeam: _localTeam,
                visitorTeam: _visitorTeam,
                state: BetStates.BetFunding,
                results: BetResults.NotStarted,       
                sponsorsCount: 0,
                gamblersCount:0,
                winnersCount:0,                          
                initialAmount:0,
                localWiningAmount:0,
                visitorWiningAmount:0,
                drawnAmount:0
            })
        );
        emit CreateBet(betIndex,_localTeam,_visitorTeam,msg.sender);

        return betIndex;
    }

    /// @author J.Gabriel Delichotti
    /** @notice Once the bet is placed Sponsors can start carrying money to attract bettors.
        Once the required amount of Sponsors is reached, the bet automatically goes to "Open" status.*/
    /** @dev Before adding Sponsors the application must validate that:
        - The bet exists (betExists)
        - The bet is in "BetFunding" status.
        - Validate that the amount to be contributed by the Sponsor is greater than the amount defined in the contract. 
        In addition, the validation to avoid the Reentry Attack is added.*/
    /// @param _betIndex is the Bet Identificator (ID)
    function addBetSponsor(uint _betIndex) public payable betExists(_betIndex) nonReentrant{        
        require(betBook[_betIndex].state == BetStates.BetFunding,"Bet is not on Bet Funding Status");
        require(msg.value > MIN_SPONSOR_AMOUNT, "The liqudity added is not enought to be a Sponsor");

        uint _currentSponsors = betBook[_betIndex].sponsorsCount;        

    /** @dev The Sponsor structure is completed as long as the previously defined criteria are met.
        In addition, the amount contributed by all sponsors is added to the betting structure (betBook) in the "initialAmount" field.*/
        if(_currentSponsors < NUM_SPONSOR_REQUIRED){                        
            betSponsors[_betIndex].push(
                Sponsor({
                    sponsorAccount:payable(msg.sender),
                    sponsorAmount: msg.value,
                    sponsorFeeAmount: 0,
                    result: BetResults.Unknown})
            );
            betBook[_betIndex].initialAmount += msg.value;
            betBook[_betIndex].sponsorsCount ++;

        /// @dev An event is issued to indicate that the Sponsor was added to a bet.
            emit AddBetSponsor(_betIndex,msg.sender,msg.value);
            
            
        }
        /// Once the last Sponsor is added, the Bet goest to the "Open" state.            
        if(betBook[_betIndex].sponsorsCount == NUM_SPONSOR_REQUIRED){
            // Si se llego al minimo de sponsor se considera que ya no pueden entrar mas sponsor y esta lista para abrirse!
            betBook[_betIndex].state = BetStates.Open;

        }           
        
    }

    
    /// @author J.Gabriel Delichotti
    /// @notice Once the bet is in "Open" states, bettors can place their bets. 
    /** @dev The application validates that:
        - The bet exists
        - The bet is in the "Open" states
        - The amount to add is greater than the minimum amount allowed (MIN_BET_AMOUNT").
        - The result entered as expected is valid.*/
    /// @param _betIndex is the Bet Identificator (ID)
    /// @param _gamblerBetoption is the result expected by the Gambler    
    function addGamblerBet(uint _betIndex, BetOptions _gamblerBetoption) public payable betExists(_betIndex) nonReentrant {
        require(betBook[_betIndex].state == BetStates.Open);
        require(msg.value > MIN_BET_AMOUNT,"The bet amount is to small");
        require(  _gamblerBetoption == BetOptions.LocalWin 
                ||_gamblerBetoption == BetOptions.VistorWin 
                ||_gamblerBetoption == BetOptions.Drawn);

        /// @dev Adds the gamblers into an array. The this array is incluede in the mapping (betGambler) where its index is the BetId
        betGamblers[_betIndex].push(
            Gambler({
               gamblerAccount: payable(msg.sender),
               betOption: _gamblerBetoption,
               betAmount: msg.value,
               betRewardPayment: 0})
        );

        /// @dev Depending on the results selected by the Gambler, the bet amount is added to the betDefinition structure.
        if(_gamblerBetoption == BetOptions.LocalWin){
            betBook[_betIndex].localWiningAmount += msg.value;
        } else if (_gamblerBetoption == BetOptions.VistorWin){
            betBook[_betIndex].visitorWiningAmount += msg.value;
        } else if (_gamblerBetoption == BetOptions.Drawn){
            betBook[_betIndex].drawnAmount += msg.value;
        } else {
            betBook[_betIndex].initialAmount += msg.value;
        }


        betBook[_betIndex].gamblersCount ++;
        emit AddBetGambler(_betIndex,msg.sender,msg.value);


    }

    
    /// @author J.Gabriel Delichotti
    /** @notice This function is triggered by the Owner of the contract when he decides that no more bets are accepted.
    In the future, this status change should be generated when a certain date and time that was defined when the bet was placed is reached.*/
    /// @dev This event, on this version, is triggered by the contract's owner. It validates that the Bet is in the "Open" state before closing.
    /// @param _betIndex is the Bet Identificator (ID)
    function closeBet(uint _betIndex) public onlyOwner betExists(_betIndex){
        // This function modifies the Bet status to CLOSE. Initially the Owner of the contract can trigger this action.
        require(betBook[_betIndex].state == BetStates.Open);
        emit CloseBet(msg.sender,_betIndex);
        betBook[_betIndex].state = BetStates.Closed;
    }


    /// @author J.Gabriel Delichotti
    /** @notice This function is where the outcome of the bet is defined. In this version it is the owner of the contract who enters the outcome. 
        In future versions it would be necessary to connect an oracle or to set up a consensus scheme. */
    /** @dev This function validates that the bet exists and that it is in the "Closed" state.
        Then it updates the variable "result" with the value provided by the owner.*/
    /// @param _betIndex is the Bet Identificator (ID)
    /// @param resultado is the result defined by the owner.
    function defineResult(uint _betIndex, BetResults resultado) public onlyOwner betExists(_betIndex){
        // This function modifies the Bet status to CLOSE. Initially the Owner of the contract can trigger this action.
        require(betBook[_betIndex].state == BetStates.Closed,"not closed");
        betBook[_betIndex].results = resultado;
        //console.log(uint(betBook[_betIndex].results));
        betBook[_betIndex].state = BetStates.ResultsReady;
        calcPayments(_betIndex);
        
    }

    /// @author J.Gabriel Delichotti
    /// @notice This function is in charge of doing the math to define the commission that the sponsors, the owner of the application and the bettors get.
    /** @dev For these calculations we used the openZeppelin release to avoid overfloating and underfloating errors.
        This function is in charge of doing the math to define the commission that the sponsors, the owner of the application and the bettors get.
        This action can only be triggered by the owner of the contract.*/
    /// @param _betIndex is the Bet Identificator (ID)
    function calcPayments(uint _betIndex) public  onlyOwner betExists(_betIndex) {
        require(betBook[_betIndex].state == BetStates.ResultsReady);

        ///@dev TotalAmount sums up the amount deposited by all gamblers.
        uint totalAmount = betBook[_betIndex].localWiningAmount 
                         + betBook[_betIndex].visitorWiningAmount 
                         + betBook[_betIndex].drawnAmount;

        ///@dev The fee amount is calculated by first multiplying and then dividing by 100 so as not to lose precision in the calculation.
        uint SponsorFeeAmount = (totalAmount * SponsorFee).div(100);
        uint OwnerFeeAmount = (totalAmount* ownerFee).div(100);
        uint gamblerReward = betBook[_betIndex].initialAmount + totalAmount - SponsorFeeAmount - OwnerFeeAmount;
        uint winners = 0;

        BetResults results = betBook[_betIndex].results;
        

        if (results == BetResults.LocalWin || results == BetResults.VistorWin ||results == BetResults.Drawn ){            
            /// @dev This process calculates the winnings of each bettor based on the bet outcome he/she has chosen.
            for (uint i=0;i < betGamblers[_betIndex].length; i++ ){
                Gambler storage _gambler = betGamblers[_betIndex][i];                
                
                if(_gambler.betOption == BetOptions.LocalWin && results == BetResults.LocalWin){                    
                    _gambler.betRewardPayment = (gamblerReward * _gambler.betAmount).div(betBook[_betIndex].localWiningAmount);                     
                } else 
                if (_gambler.betOption == BetOptions.VistorWin && results == BetResults.VistorWin){                    
                    _gambler.betRewardPayment = (gamblerReward * _gambler.betAmount).div(betBook[_betIndex].visitorWiningAmount); 
                }else 
                if (_gambler.betOption == BetOptions.Drawn && results == BetResults.Drawn){                                        
                    _gambler.betRewardPayment = (gamblerReward * _gambler.betAmount).div(betBook[_betIndex].drawnAmount);
                } else {                                        
                    _gambler.betRewardPayment = 0;
                }
                winners++;
            }
            betBook[_betIndex].winnersCount = winners;

            /// @dev This process calculates the commission that each Sponsor gets according to the amount contributed.
            for (uint i=0;i < betSponsors[_betIndex].length; i++ ){
                Sponsor storage _sponsor = betSponsors[_betIndex][i];
                _sponsor.sponsorFeeAmount = (SponsorFeeAmount*_sponsor.sponsorAmount)/betBook[_betIndex].initialAmount;
            }            
            /// @dev This bet is ready to release payments
            betBook[_betIndex].state = BetStates.ReadyForPayment;            
        }

    }
    

    /// @author J.Gabriel Delichotti
    /// @notice This function is similar to the CalPayment function but is separated from the previous one in order to have the possibility to evaluate potential payments before making them.
    /** @dev payments are made using the "call" function instead of Transfer for security reasons. It also inherits the "nonReentrant" modifier from the OpenZeppelin library.
        Finally it moves the bet to its final state: Finished. 
        This action can only be triggered by the owner of the contract.*/
    /// @param _betIndex is the Bet Identificator (ID)
    function releasePayments(uint _betIndex) public onlyOwner betExists(_betIndex) nonReentrant{
        require(betBook[_betIndex].state == BetStates.ReadyForPayment);
     
        for (uint i=0 ; i < betGamblers[_betIndex].length ; i++){
            Gambler storage _gambler = betGamblers[_betIndex][i];
            if (_gambler.betRewardPayment > 0){
                (bool sent, ) = _gambler.gamblerAccount.call{value: _gambler.betRewardPayment}("");            
                require(sent, "Failed to send Ether to Gamblers");            
                emit GamblerPayment(_gambler.gamblerAccount,_gambler.betRewardPayment);
            }
        }

        for (uint i=0 ; i < betSponsors[_betIndex].length ; i++){
            Sponsor storage _sponsor = betSponsors[_betIndex][i];
             (bool sent, ) = _sponsor.sponsorAccount.call{value: _sponsor.sponsorFeeAmount}("");            
            require(sent, "Failed to send Ether to Sponsors ");            
            emit SponsorPayment(_sponsor.sponsorAccount,_sponsor.sponsorFeeAmount);
        }        
        betBook[_betIndex].state = BetStates.Finished;
    }

    //////// UTILS FUNCTION ////////
    /** @author J.Gabriel Delichotti*/
    /// @notice This function is used in the Dapp to retrieve all the bets uploaded in the system
    function getAvailableBets() public view returns (BetDefinition[] memory availableBets){ 
        return betBook;
    }


    /** @author J.Gabriel Delichotti*/
    /// @notice This function is used in the Dapp to list the gambler of an specific bet
    function getGamblers(uint _betIndex) public view returns (Gambler[] memory gamblers) {
        return betGamblers[_betIndex];        
    }

    /** @author J.Gabriel Delichotti*/
    /// @notice This function is used in the Dapp to list the Sponsors of an specific bet
    function getSponsors(uint _betIndex) public view 
        returns ( Sponsor[] memory sponsor){
        return betSponsors[_betIndex];    
    }

    /** @author J.Gabriel Delichotti*/
    /// @notice This function is used for Testing purposes
    function getBetSummary(uint betIndex) public view 
        returns (string memory local, string memory visitor, 
                BetStates state, BetResults results,
                uint sponsorsCount, uint gamblersCount,uint winnersCount,                
                uint initialAmount, uint localWiningAmount ,uint visitorWiningAmount, uint drawnAmount) 
    {
        BetDefinition storage betSummary = betBook[betIndex];

        return (
            betSummary.localTeam,
            betSummary.visitorTeam,
            betSummary.state,
            betSummary.results,
            betSummary.sponsorsCount,
            betSummary.gamblersCount,
            betSummary.winnersCount,            
            betSummary.initialAmount,
            betSummary.localWiningAmount,
            betSummary.visitorWiningAmount,
            betSummary.drawnAmount
            
        );
    }


}